unit FtDetector;

interface

uses SysUtils,Classes,Generics.Collections,Windows;

type

{$REGION 'TFileTypes Intf'}

 TFileType = class
 public
  Signature:TBytes;
  Extensions:string;
  Description:string;
  function SignatureToString:string;
 end;

 TFileTypes = class(TObjectList<TFileType>)
 strict private
   _Exceptions:TStringList;
   _SigMaxLength:Integer;
   procedure SetSigMaxLength;
 public
   constructor Create;
   property Exceptions:TStringList read _Exceptions;
   property MaxSignatureLength:Integer read _SigMaxLength;
   function FindBySignature(sig:TBytes):TFileType;
   procedure LoadFromText(List: TStringList);
   procedure AddDelimited(TextLine:String);//commad delimited: sig, extensions, description
 end;

{$ENDREGION}

{$REGION 'TFileDetector Intf'}

 TFileDetector = class
 strict private
  _FileTypes:TFileTypes;
 public
  constructor Create;
  function Detect(Filename:string):TFileType;
  function GetFirstBytes(Filename:string):string;
  destructor Destroy;
 end;

{$ENDREGION}

implementation

{$REGION 'TFileTypes Impl'}

function TFileType.SignatureToString: string;
var
  I: Integer;
  s:string;
begin
    for I := 0 to Length(Signature) - 1 do
    begin
       s:=s+IntToHex(Signature[I],2);
    end;
    Result:=s;
end;

procedure TFileTypes.AddDelimited(TextLine: String);
var
 lst:TStringList;
  I,J: Integer;
  ft:TFileType;
  b:TBytes;
  str:string;
  strB:array of string;
begin
  try
    lst:=TStringList.Create;
    lst.Delimiter:=',';
    lst.DelimitedText:=TextLine;
    ft := TFileType.Create;
    try
      str := lst[0];

      SetLength(b,Length(str) div 2);
      SetLength(strB,Length(b));

      I:=1;
      J:=0;
      while I<=Length(str) do
      begin
        strB[J]:= '$'+str[I]+str[I+1];
        Inc(I,2);
        Inc(J,1);
      end;

      for I := 0 to Length(strB) - 1 do
      begin
        b[I] := StrToInt(strB[I]);
      end;

      ft.Signature := b;
      ft.Extensions := lst[1]; //extensions .doc .rar .jpeg
      ft.Description := lst[2]; //Description "word document, rar archive, jpeg image etc"
      Add(ft);
    except
      raise Exception.Create('Invalid Text. Must contain: sig, extensions, description');
    end;

  finally
   lst.Free;
  end;

end;

constructor TFileTypes.Create;
begin
  inherited Create;
  _SigMaxLength := 0;
  _Exceptions :=  TStringList.Create;
end;

function TFileTypes.FindBySignature(sig: TBytes): TFileType;
var
  I: Integer;
  strSig:string;
begin

   Result := nil;

   for I := 0 to Length(sig) - 1 do
   begin
      strSig:=strSig+IntToHex(sig[I],2);
   end;

   for I := 0 to Count - 1 do
   begin
     if Items[I].SignatureToString = Copy(strSig,1,Length(Items[I].Signature)*2) then
     begin
        Result := Items[I];
        Break;
     end;
   end;
end;

procedure TFileTypes.LoadFromText(List: TStringList);
var
  I: Integer;
begin

  try
    for I := 0 to List.Count - 1 do
    AddDelimited(List[I]);
  except on E:Exception do
    begin
      _Exceptions.Add('Line ['+IntToStr(I)+'] : '+E.Message);
    end;
  end;

  SetSigMaxLength;
end;

procedure TFileTypes.SetSigMaxLength;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
  begin
    if Length(Items[I].Signature)>_SigMaxLength then
    _SigMaxLength := Length(Items[I].Signature);

  end;
end;

{$ENDREGION }

{$Region 'TFileDetector Impl'}

constructor TFileDetector.Create;
var
 r:TResourceStream;
 lst:TStringList;
begin
  inherited Create;
  _FileTypes := TFileTypes.Create;
  try
    r:=TResourceStream.Create(HInstance,'SIG',RT_RCDATA);
    lst := TStringList.Create;
    lst.LoadFromStream(r);
    _FileTypes.LoadFromText(lst);
  finally
    r.Free;
    lst.Free;
  end;
end;

destructor TFileDetector.Destroy;
begin
  _FileTypes.Free;
end;

function TFileDetector.Detect(Filename: string): TFileType;
var
 f:TBytesStream;
 b:TBytes;
  I: Integer;
begin
   Result := nil;
    try
      f:=TBytesStream.Create;
      f.LoadFromFile(Filename);
      f.Position:=0;
      SetLength(b,_FileTypes.MaxSignatureLength);

      for I := 0 to _FileTypes.MaxSignatureLength - 1 do
      begin
        f.Read(b[I],1);
      end;

    finally
      f.Free;
    end;
    Result := _FileTypes.FindBySignature(b);
end;

function TFileDetector.GetFirstBytes(Filename: string): string;
var
 f:TBytesStream;
 s:string;
  I: Integer;
  b:TBytes;
begin
     try
       f := TBytesStream.Create;
       f.LoadFromFile(Filename);
       SetLength(b,10);
       for I := 0 to 10 do
       begin
         f.Read(b[i],1);
         s := s+ IntToHex(b[i],2);
       end;
     finally
      f.Free;
     end;
     Result := s;
end;

{$ENDREGION}

end.
